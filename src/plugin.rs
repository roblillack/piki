use crate::document::DocumentStore;
use std::collections::HashMap;

/// Trait for plugins that dynamically generate page content
pub trait Plugin: Send + Sync {
    /// Generate content for this plugin based on the current wiki state
    fn generate_content(&self, store: &DocumentStore) -> Result<String, String>;
}

/// Registry for managing wiki plugins
pub struct PluginRegistry {
    plugins: HashMap<String, Box<dyn Plugin>>,
}

impl PluginRegistry {
    /// Create a new empty plugin registry
    pub fn new() -> Self {
        PluginRegistry {
            plugins: HashMap::new(),
        }
    }

    /// Register a plugin with a given name
    pub fn register(&mut self, name: impl Into<String>, plugin: Box<dyn Plugin>) {
        self.plugins.insert(name.into(), plugin);
    }

    /// Check if a plugin exists with the given name
    pub fn has_plugin(&self, name: &str) -> bool {
        self.plugins.contains_key(name)
    }

    /// Generate content using the named plugin
    pub fn generate(&self, name: &str, store: &DocumentStore) -> Result<String, String> {
        self.plugins
            .get(name)
            .ok_or_else(|| format!("Plugin '{}' not found", name))
            .and_then(|plugin| plugin.generate_content(store))
    }
}

impl Default for PluginRegistry {
    fn default() -> Self {
        Self::new()
    }
}

/// Built-in plugin that generates a sorted index of all pages
pub struct IndexPlugin;

impl Plugin for IndexPlugin {
    fn generate_content(&self, store: &DocumentStore) -> Result<String, String> {
        let mut all_docs = store.list_all_documents()?;
        all_docs.sort();

        let mut content = String::from("# Index\n\n");
        content.push_str(&format!("*Dynamically generated index of all {} pages*\n\n", all_docs.len()));

        if all_docs.is_empty() {
            content.push_str("No pages found.\n");
            return Ok(content);
        }

        // Group by top-level directory
        let mut grouped: HashMap<String, Vec<String>> = HashMap::new();

        for doc in &all_docs {
            if let Some(slash_pos) = doc.find('/') {
                let category = &doc[..slash_pos];
                grouped.entry(category.to_string())
                    .or_insert_with(Vec::new)
                    .push(doc.clone());
            } else {
                grouped.entry("Root".to_string())
                    .or_insert_with(Vec::new)
                    .push(doc.clone());
            }
        }

        // Sort categories
        let mut categories: Vec<_> = grouped.keys().cloned().collect();
        categories.sort();

        // Always put "Root" first if it exists
        if let Some(pos) = categories.iter().position(|c| c == "Root") {
            let root = categories.remove(pos);
            categories.insert(0, root);
        }

        // Generate grouped output
        for category in &categories {
            if let Some(docs) = grouped.get(category) {
                if category == "Root" && categories.len() > 1 {
                    content.push_str("## Root Pages\n\n");
                } else if category != "Root" {
                    content.push_str(&format!("## {}\n\n", category));
                }

                for doc in docs {
                    content.push_str(&format!("- [[{}]]\n", doc));
                }
                content.push('\n');
            }
        }

        content.push_str("---\n\n");
        content.push_str("*This page is generated by the `index` plugin*\n");

        Ok(content)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_plugin_registry() {
        let mut registry = PluginRegistry::new();

        assert!(!registry.has_plugin("index"));

        registry.register("index", Box::new(IndexPlugin));

        assert!(registry.has_plugin("index"));
        assert!(!registry.has_plugin("nonexistent"));
    }

    #[test]
    fn test_index_plugin_empty() {
        use std::env;
        use std::fs;

        let temp_dir = env::temp_dir().join("fliki-test-plugin-empty");
        let _ = fs::remove_dir_all(&temp_dir);
        fs::create_dir_all(&temp_dir).unwrap();

        let store = DocumentStore::new(temp_dir.clone());
        let plugin = IndexPlugin;

        // Should handle empty directory gracefully
        let result = plugin.generate_content(&store);
        assert!(result.is_ok());

        let content = result.unwrap();
        assert!(content.contains("# Index"));
        assert!(content.contains("No pages found"));

        // Cleanup
        fs::remove_dir_all(&temp_dir).ok();
    }

    #[test]
    fn test_index_plugin_with_pages() {
        let store = DocumentStore::new(PathBuf::from("example-wiki"));
        let plugin = IndexPlugin;

        let content = plugin.generate_content(&store).unwrap();

        // Should contain header
        assert!(content.contains("# Index"));
        // Should be markdown
        assert!(content.contains("[["));
    }
}
